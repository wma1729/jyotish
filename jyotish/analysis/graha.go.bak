/*
package analysis

import (
	"jyotish/misc"
	"math"
)

type GrahaAttributes struct {
	Name                  string
	NaturalNature         string
	Retrograde            bool
	Combust               bool
	Position              string
}

func (attr *GrahaAttributes) getNaturalNature(name string, chart *Chart) {
	switch name {
	case SUN:
		attr.NaturalNature = MALEFIC

	case MOON:
		attr.NaturalNature = MALEFIC

		i, b := chart.GetGrahaBhava(SUN)
		sun := b.GrahaByName(SUN)

		if chart.NthBhavaContainsGraha(i, 1, MOON) {
			moon := chart.GetNthBhava(i, 1).GrahaByName(MOON)
			if moon.Degree > sun.Degree {
				attr.NaturalNature = BENEFIC
			}
		} else if chart.NthBhavaContainsGraha(i, 7, MOON) {
			moon := chart.GetNthBhava(i, 7).GrahaByName(MOON)
			if moon.Degree < sun.Degree {
				attr.NaturalNature = BENEFIC
			}
		} else {
			for n := 2; n <= 6; n++ {
				if chart.NthBhavaContainsGraha(i, n, MOON) {
					attr.NaturalNature = BENEFIC
					break
				}
			}
		}

	case MARS:
		attr.NaturalNature = MALEFIC

	case MERCURY:
		_, b := chart.GetGrahaBhava(MERCURY)
		if b.ContainsGraha(SUN) || b.ContainsGraha(MARS) || b.ContainsGraha(SATURN) ||
			b.ContainsGraha(RAHU) || b.ContainsGraha(KETU) {
			attr.NaturalNature = MALEFIC
		} else {
			attr.NaturalNature = BENEFIC
		}

	case JUPITER:
		attr.NaturalNature = BENEFIC

	case VENUS:
		attr.NaturalNature = BENEFIC

	case SATURN:
		attr.NaturalNature = MALEFIC

	case RAHU:
		attr.NaturalNature = MALEFIC

	case KETU:
		attr.NaturalNature = MALEFIC
	}
}

func (attr *GrahaAttributes) GetGrahaPosition(name string, chart *Chart) {
	_, b := chart.GetGrahaBhava(name)
	if b == nil {
		return
	}

	g := b.GrahaByName(name)
	if g == nil {
		return
	}

	ga := GrahaAttrMap[name]

	// Accurate (take degrees in account)
	if g.RashiNum == ga.Exaltation.RashiNum &&
		g.Degree >= float32(ga.Exaltation.MinDegree) &&
		g.Degree <= float32(ga.Exaltation.MaxDegree) {
		attr.Position = RASHI_EXALTED
	} else if g.RashiNum == ga.Debilitation.RashiNum &&
		g.Degree >= float32(ga.Debilitation.MinDegree) &&
		g.Degree <= float32(ga.Debilitation.MaxDegree) {
		attr.Position = RASHI_DEBILITATED
	} else if g.RashiNum == ga.Trinal.RashiNum &&
		g.Degree >= float32(ga.Trinal.MinDegree) &&
		g.Degree <= float32(ga.Trinal.MaxDegree) {
		attr.Position = RASHI_MOOLTRIKONA
	}

	// Rough (just look at the rashi as a whole)
	if attr.Position == "" {
		if g.RashiNum == ga.Exaltation.RashiNum {
			attr.Position = RASHI_EXALTED
		} else if g.RashiNum == ga.Debilitation.RashiNum {
			attr.Position = RASHI_DEBILITATED
		} else if misc.IntSliceContains(ga.Owner, g.RashiNum) {
			attr.Position = RASHI_OWN
		}
	}

	// Friendly/neutral/unfriendly
	if attr.Position == "" {
		rashiLord := RashiLordMap[g.RashiNum]
		if misc.StringSliceContains(chart.GetEffectiveFriends(rashiLord), name) {
			attr.Position = RASHI_FRIENDLY
		} else if misc.StringSliceContains(chart.GetEffectiveEnemies(rashiLord), name) {
			attr.Position = RASHI_ENEMY
		} else {
			attr.Position = RASHI_NEUTRAL
		}
	}
}

func (c *Chart) GetEffectiveFriends(name string) []string {
	for _, ga := range c.GrahasAttr {
		if ga.Name == name {
			friends := make([]string, len(ga.EffectiveBestFriends))
			m := make(map[string]bool)

			for _, item := range ga.EffectiveBestFriends {
				m[item] = true
				friends = append(friends, item)
			}

			for _, item := range ga.EffectiveFriends {
				if _, ok := m[item]; !ok {
					friends = append(friends, item)
				}
			}

			return friends
		}
	}
	return nil
}

func (c *Chart) GetEffectiveNeutrals(name string) []string {
	for _, ga := range c.GrahasAttr {
		if ga.Name == name {
			return ga.EffectiveNeutrals
		}
	}
	return nil
}

func (c *Chart) GetEffectiveEnemies(name string) []string {
	for _, ga := range c.GrahasAttr {
		if ga.Name == name {
			enemies := make([]string, len(ga.EffectiveWorstEnemies))
			m := make(map[string]bool)

			for _, item := range ga.EffectiveWorstEnemies {
				m[item] = true
				enemies = append(enemies, item)
			}

			for _, item := range ga.EffectiveEnemies {
				if _, ok := m[item]; !ok {
					enemies = append(enemies, item)
				}
			}

			return enemies
		}
	}
	return nil
}

func (attr *GrahaAttributes) Init(name string, chart *Chart) {
	attr.Name = name
	attr.getNaturalRelations(name)
	attr.getTemporalRelations(name, chart)
	attr.getEffectiveRelations(name, chart)
	attr.getNaturalNature(name, chart)
	attr.isCombust(name, chart)
	attr.Retrograde = false
	_, b := chart.GetGrahaBhava(name)
	if b != nil {
		attr.Retrograde = b.IsRetrograde(name)
	}
	// attr.getAspectedBy(name, chart)
}

*/